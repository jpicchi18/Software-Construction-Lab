#!/usr/local/cs/bin/python3

import os, sys, zlib


def topo_order_commits():

    #@@@@@ 1: FIND THE .GIT DIRECTORY @@@@@

    git_found = False;

    while (not git_found):
        cwd = os.getcwd()
        
        for i in os.listdir(cwd):
            if (i == '.git'):
                git_found = True

        if (not git_found):
            if (cwd == '/'):
                print("Not inside a Git repository", file=sys.stderr)
                exit(1)
            else:
                os.chdir(cwd+'/..')

    #@@@@@ 2: Get the list of local branch names @@@@@
    branch_stack = []
    branch_names = []

    #record path to ".git/refs/heads/"
    current_dir = cwd + '/.git/refs/heads'
    prefix = ''

    #add branch names to branches list
    first_run = True
    while (branch_stack or first_run):
        prefix = ''

        if (branch_stack):
            prefix = branch_stack.pop() + '/'
            current_dir = cwd + '/.git/refs/heads/' + prefix
            
        for entry in os.scandir(current_dir):
            if (entry.is_dir()):
                branch_stack.append(prefix + entry.name)
            elif (entry.is_file()):
                branch_names.append(prefix + entry.name)
                

        first_run = False

    #place the branches plus hashes into a dictionary "branches"
    branches = {}

    for branch in branch_names:
        f = open(cwd + '/.git/refs/heads/' + branch, 'r')
        branches[branch] = f.read().strip('\n')


    #@@@@@ 3: BUILD THE COMMIT GRAPH @@@@@
    
    #generate a list of just the values from the branch dict
    branch_hashes = []
    for i in branches:
        branch_hashes.append(branches[i])

    branch_hashes = sorted(branch_hashes)

    commit_nodes, root_hashes = build_commit_graph(cwd+'/.git/', branch_hashes)


    
    #@@@@@ 4: Generate a topological ordering of the commits in the graph @@@@@
    order = get_topo_ordered_commits(commit_nodes, root_hashes)


    #@@@@@ 5: Print the commit hashes in the order generated by the previous step,
    #         from the least to the greatest @@@@@

    #create head_to_branches:
    #a dict where the values are lists of branch names, and the value's key is the
    #corresponding commit hash that all those branch names point to
    head_to_branches = {}
    for i in branches:
        if branches[i] not in head_to_branches:
            head_to_branches[branches[i]] = []

        head_to_branches[branches[i]].append(i)

    print_topo_ordered_commits_with_branch_names(commit_nodes, order, head_to_branches)
        
    
    

def build_commit_graph(git_dir, local_branch_heads):
    #initialization
    commit_nodes = {} #dict
    root_hashes = set()
    visited = set()

    stack = local_branch_heads
    while stack:
        commit_hash = stack.pop()

        
        if commit_hash in visited:
            continue
        visited.add(commit_hash)
        
        if commit_hash not in commit_nodes:
            new_node = CommitNode(commit_hash)
            commit_nodes[commit_hash] = new_node
            
        commit_node = commit_nodes[commit_hash]

        #find parents
        #prepare for parents step
        first_two = commit_hash[0:2]
        rest_of_chars = commit_hash[2:]
        filename = git_dir + 'objects/' + first_two + '/' + rest_of_chars
        if (not os.path.exists(filename)):
            print('file does not exist: ' + filename)
            exit(1)
        
        compressed_contents = open(filename, 'rb').read()
        decompressed_contents = zlib.decompress(compressed_contents)
        decompressed_contents = decompressed_contents.decode("ascii").split("\n")

        for i in decompressed_contents:
            if ("parent" in i):
                i = i.split(" ")
                commit_node.parents.add(i[1])

        #check the parents
        if not commit_node.parents:
            root_hashes.add(commit_hash)

        for p in sorted(commit_node.parents):
             if p not in visited:
                 stack.append(p)
             if p not in commit_nodes:
                 new_node = CommitNode(p)
                 commit_nodes[p] = new_node

        #how do we record that commit_hash is a child of commit node p?
        for p in commit_node.parents:
            commit_nodes[p].children.add(commit_hash)

    root_hashes = sorted(root_hashes)
    return commit_nodes, root_hashes


def get_topo_ordered_commits (commit_nodes, root_hashes):
    #initialize
    order = []
    visited = set()
    temp_stack = []
    stack = sorted(root_hashes)

    while stack:
        v = stack.pop()

        #what do you do if v is already visited?
        if v in visited:
            continue
        visited.add(v)

        #while v is not a child of the vertex on top of the temp_stack:
        while (temp_stack and v not in commit_nodes[temp_stack[-1]].children):
            g = temp_stack.pop()
            order.append(g)

        temp_stack.append(v)

        for c in sorted(commit_nodes[v].children):
            #What do you do is c has already been visited?
            if c not in visited:
                stack.append(c)

    #Add the rest of the temp_stack to the order
    while temp_stack:
        g= temp_stack.pop()
        order.append(g)

    return order



def print_topo_ordered_commits_with_branch_names(commit_nodes, topo_ordered_commits, \
                                                 head_to_branches):
    jumped = False

    for i in range(len(topo_ordered_commits)):
        commit_hash = topo_ordered_commits[i]
        if jumped:
            jumped = False
            sticky_hash = ' '.join(commit_nodes[commit_hash].children)
            print(f'={sticky_hash}')

        branches = sorted(head_to_branches[commit_hash]) if commit_hash \
            in head_to_branches else []
        print(commit_hash + (' ' + ' '.join(branches) if branches else ''))

        if i+1 < len(topo_ordered_commits) and topo_ordered_commits[i+1] not in \
           commit_nodes[commit_hash].parents:
            jumped = True
            sticky_hash = ' '.join(commit_nodes[commit_hash].parents)
            print(f'{sticky_hash}=\n')


class CommitNode:
    def __init__(self, commit_hash):
        """
        :type commit_hash: str
        """
        self.commit_hash = commit_hash
        self.parents = set()
        self.children = set()
    


if __name__ == '__main__':
    topo_order_commits()
